//! The gRPC part of the leech.
//!
//! In server mode, the leech has a grpc server running to receive requests from ferrous.
//! If the connection drops or the leech can't send the data, it will be saved in the local
//! database and pushing the data to the server is tried regularly.
//!
//! In cli mode, the leech can push the results to ferrous if desired.

use std::net::SocketAddr;

use tonic::transport::Server;

use crate::config::Config;
use crate::rpc::attacks::Attacks;
use crate::rpc::rpc_attacks::req_attack_service_server::ReqAttackServiceServer;

pub mod attacks;

/// Missing docs are allowed, as the code gets auto generated by tonic
#[allow(missing_docs)]
pub mod rpc_attacks {
    use std::net::{IpAddr, Ipv4Addr, Ipv6Addr, SocketAddr};

    use crate::modules::bruteforce_subdomains::BruteforceSubdomainResult;
    use crate::rpc::rpc_attacks::shared::dns_record::Record;
    use crate::rpc::rpc_attacks::shared::{Aaaa, Address, Cname, DnsRecord, Ipv4, Ipv6, A};

    pub mod shared {
        tonic::include_proto!("attacks.shared");
    }

    tonic::include_proto!("attacks");

    impl From<Ipv4Addr> for Ipv4 {
        fn from(value: Ipv4Addr) -> Self {
            Self {
                address: i32::from_le_bytes(value.octets()),
            }
        }
    }

    impl From<Ipv4> for Ipv4Addr {
        fn from(value: Ipv4) -> Self {
            let [a, b, c, d] = value.address.to_le_bytes();
            Ipv4Addr::new(a, b, c, d)
        }
    }

    impl From<Ipv6> for Ipv6Addr {
        fn from(value: Ipv6) -> Self {
            let [a, b, c, d, e, f, g, h] = value.part0.to_le_bytes();
            let [i, j, k, l, m, n, o, p] = value.part1.to_le_bytes();
            Ipv6Addr::from([a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p])
        }
    }

    impl From<Ipv6Addr> for Ipv6 {
        fn from(value: Ipv6Addr) -> Self {
            let [a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p] = value.octets();
            let part0 = i64::from_le_bytes([a, b, c, d, e, f, g, h]);
            let part1 = i64::from_le_bytes([i, j, k, l, m, n, o, p]);

            Self { part0, part1 }
        }
    }

    impl From<BruteforceSubdomainResult> for BruteforceSubdomainResponse {
        fn from(value: BruteforceSubdomainResult) -> Self {
            Self {
                record: Some(match value {
                    BruteforceSubdomainResult::A { source, target } => DnsRecord {
                        record: Some(Record::A(A {
                            source,
                            to: Some(target.into()),
                        })),
                    },
                    BruteforceSubdomainResult::Aaaa { source, target } => DnsRecord {
                        record: Some(Record::Aaaa(Aaaa {
                            source,
                            to: Some(target.into()),
                        })),
                    },
                    BruteforceSubdomainResult::Cname { source, target } => DnsRecord {
                        record: Some(Record::Cname(Cname { source, to: target })),
                    },
                }),
            }
        }
    }

    impl From<SocketAddr> for TcpPortScanResponse {
        fn from(value: SocketAddr) -> Self {
            let address = match value {
                SocketAddr::V4(v) => Address {
                    address: Some(shared::address::Address::Ipv4((*v.ip()).into())),
                },
                SocketAddr::V6(v) => Address {
                    address: Some(shared::address::Address::Ipv6((*v.ip()).into())),
                },
            };

            Self {
                address: Some(address),
                port: value.port() as u32,
            }
        }
    }

    impl From<Address> for IpAddr {
        fn from(value: Address) -> Self {
            let Address { address } = value;
            match address.unwrap() {
                shared::address::Address::Ipv4(v) => IpAddr::from(Ipv4Addr::from(v)),
                shared::address::Address::Ipv6(v) => IpAddr::from(Ipv6Addr::from(v)),
            }
        }
    }
}

/// Starts the gRPC server
///
/// **Parameter**:
/// - `config`: Reference to [Config]
pub async fn start_rpc_server(config: &Config) -> Result<(), String> {
    let attacks = Attacks {};

    Server::builder()
        .add_service(ReqAttackServiceServer::new(attacks))
        .serve(SocketAddr::new(
            config.server.listen_address.parse().unwrap(),
            config.server.listen_port,
        ))
        .await
        .unwrap();

    Ok(())
}
