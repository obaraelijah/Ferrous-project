/* tslint:disable */
/* eslint-disable */
/**
 * ferrous
 * The core component of ferrous-project
 *
 * The version of the OpenAPI document: 0.1.0
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import {
    ApiErrorResponse,
    ApiErrorResponseFromJSON,
    ApiErrorResponseToJSON,
    AttackResponse,
    AttackResponseFromJSON,
    AttackResponseToJSON,
    BruteforceSubdomainsRequest,
    BruteforceSubdomainsRequestFromJSON,
    BruteforceSubdomainsRequestToJSON,
    QueryCertificateTransparencyRequest,
    QueryCertificateTransparencyRequestFromJSON,
    QueryCertificateTransparencyRequestToJSON,
    ScanTcpPortsRequest,
    ScanTcpPortsRequestFromJSON,
    ScanTcpPortsRequestToJSON,
} from '../models';

export interface BruteforceSubdomainsOperationRequest {
    bruteforceSubdomainsRequest: BruteforceSubdomainsRequest;
}

export interface QueryCertificateTransparencyOperationRequest {
    queryCertificateTransparencyRequest: QueryCertificateTransparencyRequest;
}

export interface ScanTcpPortsOperationRequest {
    scanTcpPortsRequest: ScanTcpPortsRequest;
}

/**
 * 
 */
export class AttacksApi extends runtime.BaseAPI {

    /**
     * Bruteforce subdomains through a DNS wordlist attack  Enumerate possible subdomains by querying a DNS server with constructed domains. See [OWASP](https://owasp.org/www-community/attacks/Brute_force_attack) for further information.
     * Bruteforce subdomains through a DNS wordlist attack
     */
    async bruteforceSubdomainsRaw(requestParameters: BruteforceSubdomainsOperationRequest): Promise<runtime.ApiResponse<AttackResponse>> {
        if (requestParameters.bruteforceSubdomainsRequest === null || requestParameters.bruteforceSubdomainsRequest === undefined) {
            throw new runtime.RequiredError('bruteforceSubdomainsRequest','Required parameter requestParameters.bruteforceSubdomainsRequest was null or undefined when calling bruteforceSubdomains.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/v1/attacks/bruteforceSubdomains`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: BruteforceSubdomainsRequestToJSON(requestParameters.bruteforceSubdomainsRequest),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => AttackResponseFromJSON(jsonValue));
    }

    /**
     * Bruteforce subdomains through a DNS wordlist attack  Enumerate possible subdomains by querying a DNS server with constructed domains. See [OWASP](https://owasp.org/www-community/attacks/Brute_force_attack) for further information.
     * Bruteforce subdomains through a DNS wordlist attack
     */
    async bruteforceSubdomains(requestParameters: BruteforceSubdomainsOperationRequest): Promise<AttackResponse> {
        const response = await this.bruteforceSubdomainsRaw(requestParameters);
        return await response.value();
    }

    /**
     * Query a certificate transparency log collector.  For further information, see [the explanation](https://certificate.transparency.dev/).  Certificate transparency can be used to find subdomains or related domains.  `retry_interval` is specified in milliseconds.
     * Query a certificate transparency log collector.
     */
    async queryCertificateTransparencyRaw(requestParameters: QueryCertificateTransparencyOperationRequest): Promise<runtime.ApiResponse<AttackResponse>> {
        if (requestParameters.queryCertificateTransparencyRequest === null || requestParameters.queryCertificateTransparencyRequest === undefined) {
            throw new runtime.RequiredError('queryCertificateTransparencyRequest','Required parameter requestParameters.queryCertificateTransparencyRequest was null or undefined when calling queryCertificateTransparency.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/v1/attacks/queryCertificateTransparency`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: QueryCertificateTransparencyRequestToJSON(requestParameters.queryCertificateTransparencyRequest),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => AttackResponseFromJSON(jsonValue));
    }

    /**
     * Query a certificate transparency log collector.  For further information, see [the explanation](https://certificate.transparency.dev/).  Certificate transparency can be used to find subdomains or related domains.  `retry_interval` is specified in milliseconds.
     * Query a certificate transparency log collector.
     */
    async queryCertificateTransparency(requestParameters: QueryCertificateTransparencyOperationRequest): Promise<AttackResponse> {
        const response = await this.queryCertificateTransparencyRaw(requestParameters);
        return await response.value();
    }

    /**
     * Start a tcp port scan  `exclude` accepts a list of ip networks in CIDR notation.  All intervals are interpreted in milliseconds. E.g. a `timeout` of 3000 means 3 seconds.  Set `max_retries` to 0 if you don\'t want to try a port more than 1 time.
     * Start a tcp port scan
     */
    async scanTcpPortsRaw(requestParameters: ScanTcpPortsOperationRequest): Promise<runtime.ApiResponse<AttackResponse>> {
        if (requestParameters.scanTcpPortsRequest === null || requestParameters.scanTcpPortsRequest === undefined) {
            throw new runtime.RequiredError('scanTcpPortsRequest','Required parameter requestParameters.scanTcpPortsRequest was null or undefined when calling scanTcpPorts.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/v1/attacks/scanTcpPorts`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ScanTcpPortsRequestToJSON(requestParameters.scanTcpPortsRequest),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => AttackResponseFromJSON(jsonValue));
    }

    /**
     * Start a tcp port scan  `exclude` accepts a list of ip networks in CIDR notation.  All intervals are interpreted in milliseconds. E.g. a `timeout` of 3000 means 3 seconds.  Set `max_retries` to 0 if you don\'t want to try a port more than 1 time.
     * Start a tcp port scan
     */
    async scanTcpPorts(requestParameters: ScanTcpPortsOperationRequest): Promise<AttackResponse> {
        const response = await this.scanTcpPortsRaw(requestParameters);
        return await response.value();
    }

}
